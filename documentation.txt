# Complete AHT21 I2C Communication Explanation

## Table of Contents
1. [I2C Protocol Basics](#i2c-protocol-basics)
2. [Bit-Banging Implementation](#bit-banging-implementation)
3. [AHT21 Sensor Communication](#aht21-sensor-communication)
4. [Data Reading and Conversion](#data-reading-and-conversion)

---

## I2C Protocol Basics

### What is I2C?
I2C (Inter-Integrated Circuit) is a **two-wire communication protocol** invented by Philips (now NXP). It allows multiple devices to communicate using just two lines:
- **SDA (Serial Data)**: Data line - carries actual data bits
- **SCL (Serial Clock)**: Clock line - synchronizes data transmission

### Why Two Wires?
- **SDA**: Transfers data bidirectionally (master → slave and slave → master)
- **SCL**: Master generates clock pulses to tell the slave when to read/write each bit

### Pull-up Resistors - Critical!
Both SDA and SCL lines are **open-drain**, meaning:
- Devices can only pull the line LOW (to ground)
- When released, the line floats
- **Pull-up resistors (4.7kΩ - 10kΩ) pull lines HIGH when no device is pulling them LOW**

```
     3.3V
      |
     [R] 4.7kΩ pull-up resistor
      |
    SDA/SCL ----[Device 1]----[Device 2]----[Device 3]
      |
     GND
```

Without pull-ups, the lines stay floating (undefined state) = communication fails!

### I2C States
- **IDLE**: Both SDA and SCL are HIGH (pulled up by resistors)
- **START condition**: SDA goes LOW while SCL is HIGH (signals beginning of transmission)
- **STOP condition**: SDA goes HIGH while SCL is HIGH (signals end of transmission)
- **DATA bit**: SCL pulses (LOW→HIGH→LOW) while SDA holds the bit value

---

## Bit-Banging Implementation

"Bit-banging" means manually controlling GPIO pins to implement a protocol, instead of using hardware I2C.

### Pin Control Functions

```cpp
void sda_low() {
  pinMode(SDA_PIN, OUTPUT);     // Set pin as output
  digitalWrite(SDA_PIN, LOW);   // Drive it LOW (0V)
}

void sda_high() {
  pinMode(SDA_PIN, INPUT_PULLUP); // Release pin (high-impedance)
  // Pull-up resistor brings line HIGH
}
```

**Why INPUT_PULLUP for HIGH?**
- I2C is open-drain: devices can only pull LOW
- To release the line (let it go HIGH), we set pin as INPUT
- The internal or external pull-up resistor then pulls it HIGH
- This allows other devices to also control the line

### START Condition

```cpp
void i2c_start() {
  sda_high();                  // 1. Ensure SDA is HIGH
  delayMicroseconds(I2C_DELAY);
  scl_high();                  // 2. Ensure SCL is HIGH (IDLE state)
  delayMicroseconds(I2C_DELAY);
  sda_low();                   // 3. Pull SDA LOW (while SCL is HIGH)
  delayMicroseconds(I2C_DELAY);
  scl_low();                   // 4. Pull SCL LOW (ready for data)
  delayMicroseconds(I2C_DELAY);
}
```

**Visual timing diagram:**
```
       _____           
SCL  _|     |__________  (stays LOW during data transfer)
         ___
SDA  ___|   |__________  (falls while SCL is HIGH = START)
        ^
        START condition detected here
```

The slave devices monitor SDA and detect when it falls while SCL is HIGH.

### STOP Condition

```cpp
void i2c_stop() {
  sda_low();                   // 1. Ensure SDA is LOW
  delayMicroseconds(I2C_DELAY);
  scl_high();                  // 2. Raise SCL to HIGH
  delayMicroseconds(I2C_DELAY);
  sda_high();                  // 3. Raise SDA to HIGH (while SCL is HIGH)
  delayMicroseconds(I2C_DELAY);
}
```

**Visual timing diagram:**
```
                 ______
SCL  ___________|       (goes HIGH before SDA)
                   ____
SDA  ______________|    (rises while SCL is HIGH = STOP)
                  ^
                  STOP condition detected here
```

### Writing a Byte (8 bits)

```cpp
bool i2c_write_byte(uint8_t byte) {
  // Send 8 bits, MSB (Most Significant Bit) first
  for (int i = 7; i >= 0; i--) {
    // Set SDA to the bit value
    if (byte & (1 << i)) {    // Check if bit i is 1
      sda_high();             // Bit = 1
    } else {
      sda_low();              // Bit = 0
    }
    delayMicroseconds(I2C_DELAY);
    
    // Clock the bit (slave reads on rising edge)
    scl_high();               // Rising edge → slave reads SDA
    delayMicroseconds(I2C_DELAY);
    scl_low();                // Falling edge → ready for next bit
    delayMicroseconds(I2C_DELAY);
  }
  
  // Read ACK bit from slave
  sda_high();                 // Release SDA (slave will pull LOW if ACK)
  delayMicroseconds(I2C_DELAY);
  scl_high();                 // Clock for ACK bit
  delayMicroseconds(I2C_DELAY);
  bool ack = (digitalRead(SDA_PIN) == LOW);  // LOW = ACK, HIGH = NACK
  scl_low();
  delayMicroseconds(I2C_DELAY);
  
  return ack;
}
```

**Detailed timing for sending byte 0xAC (10101100):**
```
Bit:     7   6   5   4   3   2   1   0   ACK
Value:   1   0   1   0   1   1   0   0   0(ACK)

        _   _   _   _   _   _   _   _   _
SCL  __| |_| |_| |_| |_| |_| |_| |_| |_| |__
       ___     ___     ___   ___         
SDA  _|   |___|   |___|   |_|   |_______|___
     ^M reads on rising edge of SCL
      S   each bit is stable when SCL is HIGH
      T
```

**ACK/NACK (Acknowledge/Not-Acknowledge):**
- After 8 data bits, the receiver sends an ACK bit
- **ACK (LOW)**: "I received the byte correctly"
- **NACK (HIGH)**: "Error or I'm done receiving"

### Reading a Byte (8 bits)

```cpp
uint8_t i2c_read_byte(bool ack) {
  uint8_t byte = 0;
  sda_high();  // Release SDA so slave can control it
  
  // Read 8 bits
  for (int i = 7; i >= 0; i--) {
    delayMicroseconds(I2C_DELAY);
    scl_high();                    // Rising edge
    delayMicroseconds(I2C_DELAY);
    if (digitalRead(SDA_PIN)) {    // Read SDA while SCL is HIGH
      byte |= (1 << i);            // Set bit i to 1
    }
    scl_low();                     // Falling edge
  }
  
  // Send ACK or NACK
  if (ack) {
    sda_low();   // ACK: pull SDA LOW
  } else {
    sda_high();  // NACK: leave SDA HIGH
  }
  delayMicroseconds(I2C_DELAY);
  scl_high();    // Clock the ACK/NACK bit
  delayMicroseconds(I2C_DELAY);
  scl_low();
  delayMicroseconds(I2C_DELAY);
  sda_high();    // Release SDA
  
  return byte;
}
```

**Master reads, slave sends:**
- Slave controls SDA during data bits
- Master clocks SCL and reads SDA on rising edge
- Master sends ACK after each byte (LOW = "send more", HIGH = "done")

---

## I2C Addressing

Every I2C device has a **7-bit address**. The AHT21 uses address **0x38**.

### Read vs Write Operation
The address byte includes the address + a R/W bit:
- **Bit 7-1**: Device address (0x38 = 0b0111000)
- **Bit 0**: R/W bit (0 = Write, 1 = Read)

```
Write address byte: 0x38 << 1 | 0 = 0b01110000 (0x70)
Read address byte:  0x38 << 1 | 1 = 0b01110001 (0x71)
```

### Complete Write Transaction

```cpp
bool aht_write(uint8_t* data, uint8_t len) {
  i2c_start();                                      // 1. START condition
  
  if (!i2c_write_byte(AHTX0_I2CADDR_DEFAULT << 1)) { // 2. Write address (0x70)
    i2c_stop();                                     // No ACK = device not present
    return false;
  }
  
  for (uint8_t i = 0; i < len; i++) {              // 3. Write data bytes
    if (!i2c_write_byte(data[i])) {
      i2c_stop();                                   // No ACK = error
      return false;
    }
  }
  
  i2c_stop();                                       // 4. STOP condition
  return true;
}
```

**Example: Writing command 0xBA (soft reset)**
```
START | 0x70(W+ACK) | 0xBA(ACK) | STOP
  S   |  Address    | Command   |  P
```

### Complete Read Transaction

```cpp
bool aht_read(uint8_t* data, uint8_t len) {
  i2c_start();                                         // 1. START
  
  if (!i2c_write_byte((AHTX0_I2CADDR_DEFAULT << 1) | 1)) { // 2. Read address (0x71)
    i2c_stop();
    return false;
  }
  
  for (uint8_t i = 0; i < len; i++) {
    data[i] = i2c_read_byte(i < (len - 1));          // 3. Read bytes
    // ACK all bytes except the last (NACK last = "I'm done reading")
  }
  
  i2c_stop();                                         // 4. STOP
  return true;
}
```

**Example: Reading 1 byte (status)**
```
START | 0x71(R+ACK) | [Slave sends byte] (Master sends NACK) | STOP
  S   |  Address    |      Data byte     |                    |  P
```

---

## AHT21 Sensor Communication

### Sensor Registers and Commands

The AHT21 doesn't have traditional registers. It responds to **commands**:

| Command | Hex  | Purpose |
|---------|------|---------|
| Soft Reset | 0xBA | Restart sensor without power cycle |
| Calibrate/Init | 0xE1 | Initialize sensor and enable measurements |
| Trigger Measure | 0xAC | Start temperature & humidity measurement |
| Get Status | (read 1 byte) | Check if busy or calibrated |

### Status Byte Bits

When you read 1 byte from the sensor, you get a status byte:

```
Bit:  7     6-4   3      2-0
     BUSY  (res) CAL    (res)

BUSY (bit 7): 1 = sensor is measuring, 0 = ready
CAL (bit 3):  1 = sensor is calibrated, 0 = not calibrated
```

```cpp
#define AHTX0_STATUS_BUSY 0x80        // 0b10000000
#define AHTX0_STATUS_CALIBRATED 0x08  // 0b00001000

uint8_t status = aht_get_status();
if (status & AHTX0_STATUS_BUSY) {
  // Bit 7 is set = sensor is busy
}
if (status & AHTX0_STATUS_CALIBRATED) {
  // Bit 3 is set = sensor is calibrated
}
```

### Initialization Sequence

```cpp
bool aht_init() {
  i2c_init();           // Setup GPIO pins with pull-ups
  delay(40);            // Wait for sensor power-up (datasheet: min 20ms)
  
  // Step 1: Soft Reset
  uint8_t cmd = AHTX0_CMD_SOFTRESET;  // 0xBA
  aht_write(&cmd, 1);
  delay(20);            // Wait for reset to complete
  
  // Step 2: Wait until not busy
  while (aht_get_status() & AHTX0_STATUS_BUSY) {
    delay(10);
  }
  
  // Step 3: Send calibration command
  uint8_t cal_cmd[3] = {AHTX0_CMD_CALIBRATE, 0x08, 0x00};
  // 0xE1 = command
  // 0x08 = parameter byte 1 (enables calibration)
  // 0x00 = parameter byte 2
  aht_write(cal_cmd, 3);
  delay(10);
  
  // Step 4: Wait for calibration to complete
  while (aht_get_status() & AHTX0_STATUS_BUSY) {
    delay(10);
  }
  
  // Step 5: Verify calibration
  uint8_t status = aht_get_status();
  if (!(status & AHTX0_STATUS_CALIBRATED)) {
    // Bit 3 is not set = calibration failed
    return false;
  }
  
  return true;
}
```

**Why this sequence?**
1. **Reset**: Clears any previous state
2. **Wait not busy**: Sensor needs time to reset
3. **Calibrate**: Loads calibration data from sensor's internal memory
4. **Wait not busy**: Calibration takes time
5. **Verify**: Check if calibration succeeded

---

## Data Reading and Conversion

### Triggering a Measurement

```cpp
bool aht_get_data(float* temperature, float* humidity) {
  // Step 1: Send trigger command
  uint8_t cmd[3] = {AHTX0_CMD_TRIGGER, 0x33, 0x00};
  // 0xAC = trigger measurement
  // 0x33 = parameter (enables both temp and humidity)
  // 0x00 = parameter
  aht_write(cmd, 3);
  
  delay(80);  // Typical measurement time: 80ms
  
  // Step 2: Wait until measurement is complete
  while (aht_get_status() & AHTX0_STATUS_BUSY) {
    delay(10);
  }
  
  // Step 3: Read 7 bytes of data
  uint8_t data[7];
  aht_read(data, 7);
  
  // ... convert data (explained below) ...
}
```

### Data Format (7 bytes)

When you read 7 bytes after triggering a measurement:

```
Byte:  0       1       2       3       4       5       6
      Status  H[19:12] H[11:4] H[3:0]  T[15:8] T[7:0]  CRC
                              T[19:16]

H = Humidity (20 bits total)
T = Temperature (20 bits total)
```

**Byte breakdown:**
- **Byte 0**: Status byte (same as before)
- **Bytes 1-3**: 20-bit humidity value (split across 3 bytes)
- **Bytes 3-5**: 20-bit temperature value (shared byte 3 with humidity)
- **Byte 6**: CRC checksum (not used in this code)

### Extracting Humidity (20 bits)

```cpp
// Humidity is in bytes 1, 2, and upper nibble of byte 3
uint32_t h = data[1];      // Bits 19-12
h <<= 8;                   // Shift left 8 bits
h |= data[2];              // Bits 11-4
h <<= 4;                   // Shift left 4 bits
h |= data[3] >> 4;         // Bits 3-0 (upper nibble of byte 3)

// Now h contains the 20-bit raw humidity value
```

**Visual representation:**
```
data[1]     data[2]     data[3]
76543210    76543210    76543210
HHHHHHHH    HHHHHHHH    HHHHTTTT
bits 19-12  bits 11-4   bits 3-0 + temp bits

After extraction: h = 0b HHHHHHHHHHHHHHHHHHHH (20 bits)
```

**Converting to percentage:**
```cpp
*humidity = ((float)h * 100.0) / 1048576.0;
// 1048576 = 2^20 (max value for 20 bits)
// Formula from datasheet: RH% = (raw_value / 2^20) × 100
```

**Example:**
- Raw value: 524288 (0x80000 in hex)
- Calculation: (524288 / 1048576) × 100 = 50%

### Extracting Temperature (20 bits)

```cpp
// Temperature is in lower nibble of byte 3, byte 4, and byte 5
uint32_t t = data[3] & 0x0F;  // Bits 19-16 (lower nibble of byte 3)
t <<= 8;                      // Shift left 8 bits
t |= data[4];                 // Bits 15-8
t <<= 8;                      // Shift left 8 bits
t |= data[5];                 // Bits 7-0

// Now t contains the 20-bit raw temperature value
```

**Visual representation:**
```
data[3]     data[4]     data[5]
76543210    76543210    76543210
HHHHTTTT    TTTTTTTT    TTTTTTTT
    bits 19-16  bits 15-8   bits 7-0

After extraction: t = 0b TTTTTTTTTTTTTTTTTTTT (20 bits)
```

**Converting to Celsius:**
```cpp
*temperature = ((float)t * 200.0 / 1048576.0) - 50.0;
// Formula from datasheet: T°C = (raw_value / 2^20) × 200 - 50
```

**Example:**
- Raw value: 524288 (0x80000)
- Calculation: (524288 / 1048576) × 200 - 50 = 50 - 50 = 0°C

**Why the formula?**
- Sensor outputs values from 0 to 1048576 (2^20)
- This represents -50°C to +150°C (200°C range)
- 0 = -50°C, 1048576 = +150°C
- Linear interpolation: (value / max) × range + offset

### Complete Conversion Example

Raw data bytes:
```
0x1C, 0x66, 0x84, 0xB2, 0x96, 0x7C, 0xXX
```

**Humidity extraction:**
```
h = 0x66         (102 decimal)
h << 8 = 0x6600  (26112 decimal)
h |= 0x84 = 0x6684 (26244 decimal)
h << 4 = 0x66840 (419904 decimal)
h |= (0xB2 >> 4) = h |= 0x0B = 0x6684B (419915 decimal)

Humidity = (419915 / 1048576) × 100 = 40.05%
```

**Temperature extraction:**
```
t = 0xB2 & 0x0F = 0x02  (2 decimal)
t << 8 = 0x0200         (512 decimal)
t |= 0x96 = 0x0296      (662 decimal)
t << 8 = 0x29600        (169472 decimal)
t |= 0x7C = 0x2967C     (169596 decimal)

Temperature = (169596 / 1048576) × 200 - 50 = 32.34 - 50 = -17.66°C
```

---

## Why Bit-Banging Works When SoftWire Failed

### SoftWire Library Issues
- Depends on specific Arduino core implementations
- May have timing issues or bugs on ESP32
- Uses interrupts or complex state machines
- Can hang if timing is slightly off

### Bit-Banging Advantages
- **Direct control**: You control every single LOW/HIGH transition
- **Visible timing**: You can see exactly when delays happen
- **Debugging**: Easy to add Serial.print() between steps
- **Portable**: Works on any microcontroller with GPIO
- **No dependencies**: No library bugs to deal with

### The Trade-offs
- **Slower**: Software delays vs hardware timing
- **CPU intensive**: Microcontroller can't do other things during I2C
- **More code**: You implement the entire protocol yourself
- **But it works reliably!**

---

## Summary

1. **I2C Protocol**: Two wires (SDA, SCL) with pull-up resistors, using START/STOP conditions and byte-by-byte ACK
2. **Bit-Banging**: Manual GPIO control to create I2C signals, giving complete control
3. **AHT21 Commands**: Reset (0xBA), Initialize (0xE1), Trigger (0xAC), Read Status
4. **Data Conversion**: Extract 20-bit values from byte arrays, apply formulas to get real-world units

The key to making it work was **implementing the I2C protocol from scratch** with precise timing control, which gave us reliable communication with the sensor!
